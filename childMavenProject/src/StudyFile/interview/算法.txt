青蛙跳台阶问题：斐波那契数列，当前 = 上一个（n-1)的跳法 + 上上一个（n-2)的跳法

贪心算法，每一个局部最优。
普通背包问题，求出每个物品权值，然后使用权值最大装入背包。
  青蛙，一次可以跳，1-n个台阶，n个台阶，青蛙有多少种跳法。
  当前n = 1-->n-1个台阶的跳法累加。
  n-1 = 1-->n-2个台阶的跳法累加。

  f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)= f(0) + f(1) + f(2) + f(3) + ... + f(n-2)+f(n-1)
  f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)
  so  f(n)=2*f(n-1)

  public int jump(int n){
    if(n==1) return 1;
    return 2*jump(n-1)
  }
  n = 2(n-1)

正数二进制：5 0101，负数补码：-5 11111111111111111111111111111010

负数 = 32 - 正数中1的个数 = 负数中1的个数
暴力法
5 & (5-1)
0101 & 0100 = 0100 & 0011 = 0000;

x^y 求 2 ^ -3 1/2^3

0，1背包问题，不可拆解，贪心算法算出来的结果不是最优解。
使用动态规划算法。
0111         -8 1000 1000
2^3 - 1 = 7,
        int[][] a = {}
        1,2,3,4,5,5
        4,5,6,4,5,5
        7,8,9,4,5,5
        7,8,9,4,5,5
        7,8,9,4,5,5
        7,8,9,4,5,5

        1 1 (i/2 + i%2)
        2 1
        3 2
        4 2
        5 3
        6 3
        for(int i = 0;i<a.length;i++){
          System.out.println(a[i][])
        }















end
